#!/bin/bash

# META-begin
# dndmate - drag-and-drop collector and automator
# Copyright (C) step, 2017-2018
# License: GNU GPL Version 2
  Homepage=https://github.com/step-/scripts-to-go
  Version=1.3.0
# Required shell libraries: yad-lib >= 1.0.0
# Required packages: yad >= 0.40.3 **git b3a99043**, gawk >= 4.1.1, findutils >= 4.4.2, bash >= 4.3
# Suggested packages: netpbm-advanced >= 10.64 for set_TRANSPARENT_GIF
# META-end

# -----------------------------------------
# The only user-configurable default value otherwise see: dndmate --help=all.
#DNDMATE_YAD_INITIAL_POSITION="${DNDMATE_YAD_INITIAL_POSITION:---mouse}"
# -----------------------------------------

usage() # [$1-cmdline-option] {{{1
{
  # TODO i18n
  local lte=$'\u2264'
  [ "$1" != --help=gui -a "$1" != --help=print ] &&
  cat << EOF
Usage: $SN [OPTIONS] [REF...]
  Drag-and-drop ITEMs to save their REFerences into the "Refs" file and update
  the List View. ITEMs are files, folders, browser URLs. REFs are their textual
  full paths and URLs. Sub-folder contents aren't included.
TLDR;
  Read full help in a window: $SN --help=gui
  Silently append: --append-exit REFs
  Append without new window: --no-restart --append REFs
  Don't add duplicate REFs: --uniq --append REFs
  Close a group of windows: --id=GroupID --close -exit
  Change drop target symbol and window icon: --glyph=$'\\u25cf' --fgcolor=navy
  Apply symbol and icon from the style file: --stylef=:-MyMusic
  Empty the list and the reference file: --zap
OPTIONS:
  Short options can't be combined together. '=' before option value is required.
  -h|--help[=all|=gui|=print]  Show help and exit =all(extended) =gui(window)
  --help=homepage  Open program home page.
  -a|--append      Append to DNDMATE_REFS. Default if no --zap. {1}
  --append-exit    Append to DNDMATE_REFS, process OPTIONS then exit. {1} {e2}
  --debug[=FILE]   Trace to debug log FILE (default $DEBUG_LOG_FILE)
  --bgcolor=BC     Glyph background color, BC:= SVG color SPEC + 'none'.
  --close          Close any other running instance with the same ID. {1}
  --exit           Exit the current instance immediately. {1}
  --fgcolor=FC     Glyph color, FC:= SVG SPEC.
  --font-family=FF Font family (default: the system font), FF:= SVG text SPEC.
  --glyph          Glyph in the drag-and-drop pane. {4}
  --glyph-scale=N% Fit larger glyphs. 0 < N $lte 100 integer, default 90.
  --height=H       Set window height.
  --id[=ID]        Arbitrary ID string for DNDMATE_REFS. No "=ID" auto-generates.
  --mult=M         Drag-and-drop glyph size multiplier, integer M > 0. Default 5.
  --style=C        Customize dialog style. {5}
  --stylef=FILE:P  Read values of --id, --glyph, --glyph-scale, --style,
                   --fgcolor, and --bgcolor from FILE at P {7}.
  --no-edit        Disallow editing the List widget items.
  --no-restart     Do not restart (refresh) the main window after adding REFs. {1}
  --optf=FILE      Insert OPTIONS from FILE. {2}
  --print=TOPICS   Print TOPICS to stdout and exit. --print=ref,check {3}
  --uniq           Do not add duplicated REFs. {e1}
  --version        Print "$Version" and exit.
  --width=W        Set window width.
  -Z|--zap         Empty the "Refs" file. --append disables --zap. {e2}
  --               Stop processing options.
EOF
case $1 in
  --help=all ) : pass-through to show extended help ;;
  --help=gui )
    usage --help=all |
    yad --width=700 --height=600 --center --window-icon=gtk-help \
      --text-info --button=gtk-ok --button=gtk-print:"$0 --help=print" &
    return
    ;;
  --help=print )
    local p=/tmp/$SN-print.$$
    usage --help=all > "$p" &&
      yad --center --window-icon=gtk-print \
      --print --type=TEXT --filename="$p" --add-preview
    return
    ;;
  --help=homepage ) defaultbrowser $Homepage || xdg-open $Homepage ;;
  * ) printf "\033[7m%s\033[0m\n" \
    "Type ${0##*/} --help=all for extended help, notes and examples."; false
    ;;
esac &&
  cat << EOF
Reference File - DNDMATE_REFS and REFs
  REFs are stored in file '$DNDMATE_REFS', and
  raw List View contents in file '$DNDMATE_LIST'.
  To change both file paths set environment variable DNDMATE_REFS, i.e.
    env DNDMATE_REFS=/folder/user-\$USER-%s.txt $SN --id=ThisID [REFs]
  where the value of option --id (default value: \$\$) replaces "%s". {6}
  When REFs are passed with --append they can be arbitrary strings, and a new
  main window is started.  Already open windows aren't refreshed. {1}
List View
  Select the List View, press Ctrl+F, type a regular expression to find an
  item. Select then click or right-click an item to edit the list in place.
  You can also edit the List File with the default Editor Program.
Command Execution - SHELL (login shell)
  Click "Run" and enter COMMAND; this runs: \$SHELL -c "COMMAND". Append "\$@"
  to COMMAND to pass it the checked items.
Command History - DNDMATE_HISTORY
  Typed commands are stored in file '$DNDMATE_HISTORY',
  where the value of option --id (default value \$\$) replaces "%s". {6}
  To customize the file path set environment variable DNDMATE_HISTORY, i.e.
    env DNDMATE_HISTORY=\$HOME/.cache/$SN-history.sh $SN
History Editor Program - DNDMATE_EDITOR
  The default program can be changed by setting environment variable
  DNDMATE_EDITOR. Current value: "$DNDMATE_EDITOR"
Yad Options - DNDMATE_YAD_OPTIONS, DNDMATE_YAD_INITIAL_POSITION, DNDMATE_STYLEF
  Pass extra yad options (not all will apply) using environment variable
  DNDMATE_YAD_OPTION. See 'man yad' for a list of valid options.
  Consider the following: --on-top --no-focus --undecorated i.e.
    env DNDMATE_YAD_OPTIONS="--on-top --undecorated" $SN
  Control the main window initial position by setting environment variable
  DNDMATE_YAD_INITIAL_POSITION (default: window manager placement):
    env DNDMATE_YAD_INITIAL_POSITION="--center" $SN # or --mouse
  Change size and look of the main window by setting DNDMATE_STYLEF {7}
    env DNDMATE_STYLEF=: $SN    # /usr/share/$SN/stylef
Known Bugs and Limitations
* The ENTER key is disabled. Use Alt+O (OK), Alt+C (Cancel), ESC.
* Occasionally the main window could stop responding. Close it and kill its
  yad processes, which can be listed with command: ps \$(pidof yad)
Notes
{1} Command lines commonly used to append REFs and manage open windows:
  Silently append: --append-exit REFs.
  Append without new window: --no-restart --append REFs (open windows aren't refreshed).
  Close existing windows by ID then append: --id=ID --close --exit. Then --append REFs.
{2} One option per line; lines are used as they appear (verbatim). FILE path is
  resolved relative to the working directory first then to the script directory.
{3} TOPICS is a comma-separated list of words: 'ref' (print the "Refs" file),
  'check' (refs and checkmarks). A blank line separates multiple printed topics.
{4} Example: --glyph=$'\\u25cf' --fgcolor=navy. The glyph shape and colors are
  used for the main window icon, too.
{5} For option --style each character of C, modifies the dialog as follows:
    c:compact window, h:horizontal layout, v:vertical layout, x:list expander,
    I:no button icons, L:no button labels, T:no button tooltips.
      $SN --style=cIvx   ;   $SN --style=cLv
{6} Adding %s to the custom path isn't mandatory.
{7} Values in --stylef override the corresponding options except --id.
    If FILE is omitted, it's filled in with the first '$SN/stylef' in
    \$XDG_CONFIG_HOME:\$USER/.config:\$XDG_DATA_DIRS:/usr/share
    Position P can be a line number or range, null or a label. See
    /usr/share/$SN/stylef for details. {e3}
Examples
{e1} -a --uniq --close REF1 REF2 &  Add unique REFs and refresh the GUI
{e2} --close --zap --exit &  Reset DNDMATE_REFS and close all GUIs
     [--zap] --append-exit REFs &  [Reset] and append REFs without GUI
{e3} --stylef=:1 ; --stylef=:2-6 ; --stylef=: ; --stylef=:MyMusic
----
EOF
}

set_APP_ICON_and_SPLITTER_SIZE() # $1-int:scale-factor $2-glyph $3-fgcolor $4-bgcolor $5-font-family $6-glyph-scale {{{1
{
  local s=${1:-$opt_mult} glyph=${2:-$opt_glyph} fgcolor=${3:-$opt_fgcolor} bgcolor=${4:-$opt_bgcolor} font_family=${5:-$opt_font_family} glyph_scale=${6:-$opt_glyph_scale}
  glyph=${glyph:0:1}
  [ "$font_family" ] && font_family=" font-family=\"$font_family\""
  local text_x=$((50+(100-$glyph_scale)/2)) text_y=$((81+(100-$glyph_scale)/2)) 
  local scale=0.$glyph_scale; [ 0.100 = $scale ] && scale=1
  local font_size=$((s*8 +(s -1)*3 -s/2))
  declare -g SPLITTER_SIZE=$((s*17 +2)) APP_ICON="${TMPDIR:-/tmp}/.$USER-$SN-$glyph-$glyph_scale-${fgcolor//[# ]}-${bgcolor//[# ]}.svg"
  echo '<svg width="'$((s*16))'" height="'$((s*17))'" version="1.1" viewBox="0 0 '$((s*8))' '$((s*8))'" xmlns="http://www.w3.org/2000/svg"><rect width="100%" height="100%" fill="'$bgcolor'"/><text x="'$text_x'%" y="'$text_y'%"'"$font_family"' font-size="'$font_size'" fill="'$fgcolor'" text-anchor="middle" transform="scale('$scale,$scale')">'$glyph'</text></svg>' > "$APP_ICON"
  # https://www.w3.org/TR/SVG/text.html#TextElement
}

set_SPLITTER_WORKAROUND() # {{{1
# Motivation: Work around the following issue.
# Yad's --splitter is broken for --paned because yad draws the splitter at a
# fixed X position, which corresponds to the dialog button container box width,
# regardless of the requested --splitter=W value. The fixed splitter can crop
# out part of the --dnd image when the button container width is small due to
# few/no/small buttons (cf. --style=cLI). This work-around puts a Wx1
# transparent line on top of the --paned dialog (in show_main_dialog) which
# pushes the splitter to the requested X position.
{
  declare -g SPLITTER_WORKAROUND
    set_TRANSPARENT_GIF $SPLITTER_SIZE 1 && [ -s "$TRANSPARENT_GIF" ] &&
    SPLITTER_WORKAROUND="--image=$TRANSPARENT_GIF --image-on-top"
}

set_TRANSPARENT_GIF() # $1-width $2-height {{{1
{
  local -i w=$1 h=$2
  declare -g TRANSPARENT_GIF="${TMPDIR:-/tmp}/.$USER-$SN-$w-$h.gif"
  [ -s "$TRANSPARENT_GIF" ] && return
  ! type pnmtile pamtogif &>/dev/null && return
  printf "P4\n1 1\n\0" | # 1x1 bi-color white image
    pnmtile $w $h | pamtogif -transparent=white 2>/dev/null >"$TRANSPARENT_GIF"
}

_dndmate_print_quoted_var_assignment() # $1-varname [$2-rename-varname] {{{1
# Print varname=value with fully-escaped quoting. Rename too if $2.
# varname must exist.
{
  local x="$(declare -p $1)"
  x="${x#declare -? }"
  [ "$2" ] && x="$2=${x#*=}"
  echo "$x"
}; export -f _dndmate_print_quoted_var_assignment

_dndmate_list_existing() # [--grep=pat] [-grepv=pat] $1-what $2-start-with [$3-add-prefix] [$4-add-suffix] {{{1
# List compgen category ('export' | 'variable' | 'function' | ...) item
# that start with start-with; add prefix and suffix to all found items.
{
  local include exclude
  if [[ $1 == --grep=*  ]]; then include="${1#--grep=}";  shift; fi
  if [[ $1 == --grepv=* ]]; then exclude="${1#--grepv=}"; shift; fi
  local what=$1 start_with=$2 prefix=$3 suffix=$4 name sep
  compgen -A $what $start_with | while read name; do
    [[ -n "$include" && ! $name =~ $include ]] && continue
    [[ -n "$exclude" &&   $name =~ $exclude ]] && continue
    echo -n "${sep}${prefix}${name}${suffix}"
    sep=' '
  done
  echo
}; export -f _dndmate_list_existing

_dndmate_get_state_with_lock() # {{{1
{
#DEBUG_state { printf "%5d %s: "  ${BASH_LINENO[0]} ${FUNCNAME[1]}; tail -n +${BASH_LINENO[0]} "${BASH_SOURCE[1]}" |head -1; }>&2
  ! [ -s "$DNDMATE_STATE" ] && return
  exec 9< "$DNDMATE_STATE"
  flock -s 9 # acquire read lock
  . "$DNDMATE_STATE"
  flock -u 9 # release lock
  exec 9<&-
}; export -f _dndmate_get_state_with_lock

_dndmate_save_state_with_lock() # $1-varname {{{1
# Add (or replace) varname=value in the state file with valid shell syntax.
# Varname must start with 'state_'.
# Note that an assignment statement can extend over multiple lines.
{
#DEBUG_state { printf "%5d %s: "  ${BASH_LINENO[0]} ${FUNCNAME[1]}; tail -n +${BASH_LINENO[0]} "${BASH_SOURCE[1]}" |head -1; }>&2
  local varname=$1 x

  exec 9>> "$DNDMATE_STATE"
  flock -x 9 # acquire write lock
  if ! [ -s "$DNDMATE_STATE" ]; then # Add
    _dndmate_print_quoted_var_assignment "$varname" > "$DNDMATE_STATE"
  else # Replace
    # Append the new assignment to the end of the state file. So when
    # the file is sourced the new assignment wins over an existing one.
    _dndmate_print_quoted_var_assignment "$varname" >> "$DNDMATE_STATE"
    # Delete double assignments from the state file.
    ## Unset variable names that start with 'state_'
    ## This is done in order to prevent injections.
    unset x $(_dndmate_list_existing variable state_)
    # Read back all variables; last assignments prevail.
    . "$DNDMATE_STATE"
    for x in $(_dndmate_list_existing variable state_); do
      _dndmate_print_quoted_var_assignment $x
    done > "$DNDMATE_STATE"
  fi
  flock -u 9 # release lock
  exec 9>&-
}; export -f _dndmate_save_state_with_lock

_dndmate_write_data_by_id_with_lock() # $1-data $-id [$3-mode] {{{1
# Write $1-data to a shared record with flock. $2-id is the record key.
# $3-mode applies to a record and can be 'w'(write) or 'w+'(append).
# Record format: ^<key1>\n<data1,1>\n<data1,2>\n...<data1,N>\n\n
{
#DEBUG_state { printf "%5d %s: "  ${BASH_LINENO[0]} ${FUNCNAME[1]}; tail -n +${BASH_LINENO[0]} "${BASH_SOURCE[1]}" |head -1; }>&2
  local data="$1" id="${2:-ERROR-NO-KEY}" mode=${3:-w+} # append
  exec 9>>"$DNDMATE_DATA_BY_ID" # database and lock file
  flock -x 9 # acquire write lock
  awk -v KEY="$id" -v DATA="$data" -v MODE=$mode '
BEGIN { RS=""; FS="\n" } # \n\n separates records, \n separates fields
{ K[++nK] = $1; R[$1] = $0 } # $1 is an id
END {
  if(KEY in R) {
    # Append to or replace existing record according to MODE.
    R[KEY] = (MODE == "w+" ?R[KEY] :KEY) "\n" DATA
  } else {
    # Write new record.
    K[++nK] = KEY; R[KEY] = KEY "\n" DATA
  }
  # Write all records back to the input file.
  for(i = 1; i <= nK; i++) printf "%s\n\n", R[K[i]] > FILENAME
} ' "$DNDMATE_DATA_BY_ID"
  flock -u 9 # release lock
  exec 9>&-
}; export _dndmate_write_data_by_id_with_lock

_dndmate_read_data_by_id_with_lock() # $1-id {{{1
# Print data of a shared record with flock. Id is the record key.
{
#DEBUG_state { printf "%5d %s: "  ${BASH_LINENO[0]} ${FUNCNAME[1]}; tail -n +${BASH_LINENO[0]} "${BASH_SOURCE[1]}" |head -1; }>&2
  ! [ -s "$DNDMATE_DATA_BY_ID" ] && return
  local id="${1:-ERROR-NO-KEY}"
  9<"$DNDMATE_DATA_BY_ID" # database and lock file
  flock -s 9 # acquire read lock
  awk -v KEY="$id" 'BEGIN {RS=""; FS="\n"} ($1==KEY)' "$DNDMATE_DATA_BY_ID"
  flock -u 9 # release lock
  exec 9<&-
}; export _dndmate_read_data_by_id_with_lock

_dndmate_itemize() # [args] {{{1
# Invoked with: bash -c _dndmate_itemize ... (GUI drop)
# OR   _dndmate_itemize REF [REF...] (command-line)
{
#{ _dndmate_func_in _dndmate_itemize; _dndmate_list_refs; } >&2
  local p
  if [ 0 = $# ]; then
   # Whence: bash -O extdebug -c _dndmate_itemize '_dndmate_itemize' dropped-item
    # $0 gets '_dndmate_itemize', which acts as label for bash error messages.
    # Strangely, $1 gets null - you'd think it got assigned to dropped-item.
    # Work-around: invoke bash -O extdebug to get dropped-item from $BASH_ARGV.

    # Try to get "exclusive" access to stdout. It matters for multi-drops.
    while [ -e "$DNDMATE_LOCK" ]; do sleep .1$(($RANDOM % 100)); done
    : >> "$DNDMATE_LOCK"
    # yad adds protocol(http:// etc.) prefix; strip 'file://'
    p="${BASH_ARGV#file:\/\/}" # there's actually only one array element.
    # Urlencode the tooltip column.
    _dndmate_urlencode "$p" for-pango # => $REPLY
    # Add item to list widget.
    # Columns: checkbox,ref,urlencoded,@font@
    printf "%s\n%s\n%s\n%s\n" true "$p" "$REPLY" ""
    # Release "exclusive" access to stdout.
    rm "$DNDMATE_LOCK"
    # Copy item to $1 for further output.
    set -- "$p"
  fi
  # Whence? bash -c and command-line invocation.
  : >> "$DNDMATE_REFS"
  local -a a=( "$@" )
  local -i len=$#
  for ((p=0; p < $len; p++)); do
    if [ "$opt_uniq" ] && grep -m1 -qxF "${a[$p]}" "$DNDMATE_REFS"; then
      unset a[$p]
      continue
    fi
    echo "${a[$p]}" >> "$DNDMATE_REFS"
  done
  for p in "${a[@]}"; do
    _dndmate_urlencode "$p" for-pango # => $REPLY
    # Columns: checkbox,ref,urlencoded,@font@
    printf "%s|%s|%s|%s|\n" TRUE "$p" "$REPLY" ""
  done >> "$DNDMATE_LIST"
#local ret=$?; { _dndmate_func_out _dndmate_itemize; _dndmate_list_refs; } >&2; return $ret
}; export -f _dndmate_itemize

set_B_L_I_T() # $1-msg {{{1
# Assign button labels, icons and tooltips.
{
  local msg="${1:+$'\n'}$1"
  declare -gA B L I T
  if ! [[ $opt_style =~ L ]]; then # label
    L=( \
      [zap_]="$(gettext _Z)" \
      [quit]="$(gettext _Q)" \
      [run1]="$(gettext _R)" \
      [edit]="$(gettext _E)" \
      [help]="$(gettext _H)" \
    )
  fi
  if ! [[ $opt_style =~ I ]]; then # icon
    I=( \
      [zap_]="gtk-clear" \
      [quit]="gtk-quit" \
      [run1]="gtk-execute" \
      [edit]="gtk-edit" \
      [help]="gtk-help" \
    )
  fi
  if ! [[ $opt_style =~ T ]]; then # tooltips
    T=( \
      [zap_]="$(gettext "Zap list and forget items")" \
      [quit]="$(gettext "Quit")" \
      [run1]="$(gettext "Run command for checked items...")" \
      [edit]="$(gettext "Edit list file...")" \
      [help]="$(gettext "Help")$msg" \
    )
  fi
  for k in "${!L[@]}" "${!I[@]}"; do B[$k]="--button="; done
  [ 0 = ${#B[*]} ] && B[none]="--no-buttons"
}

set_options_from_stylef() # $1-stylef ::= FILEPATH:POSITION {{{1
{
  declare -g opt_id opt_style opt_width opt_height opt_glyph opt_glyph_scale opt_mult opt_fgcolor opt_bgcolor # {{{1
  #{{{1 ^^^ The global options that we are going to change. ^^^
  local f=${1%:*} pos=${1##*:} N line label nA
  local -A A
  if [ -z "$f" ]; then
    for f in $XDG_CONFIG_HOME $USER/.config ${XDG_DATA_DIRS//:/ } /usr/share; do
      [ -e "$f/$SN/stylef" ] && break
    done
    f="$f/$SN/stylef"
  elif ! [ -e "$f" ]; then
      echo "${0##*/}: $f: $(gettext 'file not found')" >&2
      return 1
  fi
  # POSITION to LINENUMBER.
  # POSITION can be a LINENUMBER, a LINENUMBER_RANGE, null or a LABEL/ID.
  # LINENUMBER is interpreted modulus the number of lines in FILEPATH.
  # LINENUMBER_RANGE is LINENUMBER_a'-'LINENUMBER_b with a < b.
  # If POSITION is LINENUMBER_RANGE or null, a random LINENUMBER is generated
  # within the given line range or all file lines respectively.
  # LABEL/ID identifies a line that starts with a text label followed by ';'.
  # A LABEL starts with '-' otherwise it's an ID.
  if [[ $pos =~ ^[[:digit:]]+$ ]]; then
    N=$pos
  elif [[ $pos =~ ^[[:digit:]]+-[[:digit:]]+$ ]]; then
    local a=${pos%-*} b=${pos#*-}
    N=$(($RANDOM % ($b-$a+1) +$a))
  elif ! [ "$pos" ]; then
    N=$RANDOM
  elif [[ $pos == -* ]]; then
    N=LABEL
  else
    N=ID
  fi
  # Seek to $N. '#' starts a comment line.
  # Comments and blank lines don't count against seeking to line $N.
  # Line format: [LABEL/ID';'] ...
  nA=0; while read line; do
    [[ $line =~ ^[[:space:]]*(#|$) ]] && continue # comment line / white line
    [[ $line == ?*\;?* ]] && label="${line%%;*}" || unset label
    A[$((++nA))]="$line"
    [ "$label" ] && A["$label"]="$line"
    [ $N = $nA ] && break # Note: iff $N is numeric
  done < "$f"
  if [ $N = LABEL -o $N = ID ]; then
    line="${A["$pos"]}"
  elif [ $nA -gt 0 ]; then # apply modulus for numeric $N
    [ $N = $nA ] && line="${A[$N]}" || line="${A[$(( ($N-1) % nA +1 ))]}"
  fi
  # Line format: [ID;]style,width,height,glyph,glyph-scale,mult,fgcolor,bgcolor.
  line="${line#-*;}" # chop LABEL
  # Set command line option values.
  local t IFS=,
  set -- $line
  t=$1
  if [[ $1 == ?*\;* ]]; then
    [ -z "$opt_id" ] && opt_id="${1%%;*}" # don't override --id
    t=${1#*;}
  fi
  [ "$t" ] && opt_style=$t
  [ "$2" ] && opt_width=$2
  [ "$3" ] && opt_height=$3
  [ "$4" ] && opt_glyph=$4
  [ "$5" ] && opt_glyph_scale=$5
  [ "$6" ] && opt_mult=$6
  [ "$7" ] && opt_fgcolor=$7
  [ "$8" ] && opt_bgcolor=$8
}

_dndmate_show_run_input_dialog() # $1-main-button {{{1
# A text entry combo box widget, which reads command input.
{
  local main_button=$1 # Run-without-questions(12)
  local selected entry escaped h nHistory
  local edit_cmd edit_tt=$(gettext "Edit history list...")
  local -a History

  # Get last typed command from the state file.
  _dndmate_get_state_with_lock
  yad_lib_set_YAD_GEOMETRY '' '' '90:-1:-1:-1:-1:-1'
  # Combo box default selection.
  if [ -z "$state_command_entry" ]; then
    # First run. Show example with GUI output.
    escaped=$(gettext ': example; printf "%s\\n" "$@" | yad --title="Example `date +%T`" --width=300 --text-info --button=gtk-ok')
  else
    # Yad needs an "escaped" version of $state_command_entry.
    escaped=$state_command_entry_escaped
  fi
  selected=$escaped

  # Combo box items are loaded from the history file.
  ! [ -s "$DNDMATE_HISTORY" ] && echo "$escaped" > "$DNDMATE_HISTORY"
#DEBUG { _dndmate_func_in; _dndmate_recho "$DNDMATE_HISTORY"; cat -n "$_"; } >&9
  nHistory=0; while IFS= read -r h; do
    [ "$selected" != "$h" ] && History[((nHistory++))]=$h
  done < "$DNDMATE_HISTORY"

  # Command for the history edit button. I added stdout redirection to work
  # around an issue: opening the editor, then closing dndmate's main window,
  # then closing the editor ends the X11 session! I suspect the window manager
  # gets a bogus TERM signal in the process/signal maze.
  edit_cmd="exec >&2; $DNDMATE_EDITOR \"$DNDMATE_HISTORY\" &"
  # Close the input dialog w/ $?=1 and no output before the editor starts.
  edit_cmd+=" kill -USR2 \$YAD_PID"

#DEBUGrun_button { printf "%5d %s: "  $LINENO $FUNCNAME; echo "Run dialog prompt..."; }>&2
  # For the combo box I use CBE --form rather than --editable --entry (ee)
  # because ee starts with a blank field while CBE fills the field with
  # $selected. To keep Gtk from highlighting the entry text by default, which
  # changes the selection clipboard, set "gtk-entry-select-on-focus = 0" in
  # ~/.gtkrc-2.0.  An alternative implementation that uses ee is commented out
  # after this block.
  # Below: Implode array History by separator S with $selected inserted.
  entry=$(S=$'\n' IFS=; _dndmate__yad --mouse --text="" \
    --item-separator="${S}" --separator='' --window-icon=gtk-execute \
    --form --field=:CBE "^$selected${History[*]/#/${S}}" \
    --button=gtk-cancel:2 --button=gtk-ok:0 \
    --button="$(gettext _Edit)${S}gtk-edit${S}$edit_tt:bash -c '$edit_cmd'"; \
    echo state_last_run_button=$? >> "$DNDMATE_STATE")
#DEBUGrun_button { _dndmate_get_state_with_lock; printf "%5d %s: "  $LINENO $FUNCNAME; echo "state_last_run_button($state_last_run_button)"; }>&2

  # Alternative, unmaintained implementation based on --editable --entry (ee).
  # Uncomment below and comment above for a different user experience.
  # S=$'\b' # yad value item separator
  # entry=$(S=$'\b'; yad --on-top --mouse --text=""$'\n' \
  #   --item-separator="${S}" \
  #   --editable --entry --entry-text="$selected" --rest "$DNDMATE_HISTORY" \
  #   --button=gtk-cancel:2 --button=gtk-ok:0 \
  #   --button="$(gettext _Edit)${S}gtk-edit${S}$edit_tt:bash -c '$edit_cmd'"; \
  # echo state_last_run_button=$? >> "$DNDMATE_STATE")

  # Save entry and history to the state file if user clicked OK.
  _dndmate_get_state_with_lock
  if [ 0 = $state_last_run_button ]; then
    if ! [[ "$entry" =~ [[:graph:]] || "$entry" =~ ^[[:cntrl:]]*$ ]]; then
      # Invalid entry. Simulate Cancel button.
      state_last_run_button=2; _dndmate_save_state_with_lock state_last_run_button
    else
      state_command_entry=$entry; _dndmate_save_state_with_lock state_command_entry
      # Yad expands backslash sequences from cmdline args and --rest file.
      # Escape all backslashes enough times to protect them.
      escaped=${entry//\\/\\\\}
      state_command_entry_escaped=$escaped; _dndmate_save_state_with_lock state_command_entry_escaped
      # Save history. Move/insert entry before line 1.
      {
      echo "$escaped"
      [ "$escaped" != "$selected" ] && echo "$selected"
      printf "%s\n" "${History[@]}"
      } > "$DNDMATE_HISTORY"
    fi
  fi
}; export -f _dndmate_show_run_input_dialog

confirm_then_run_command() # $1-main-button {{{1
{
  _dndmate_get_state_with_lock
  # Test if OK button clicked in _dndmate_show_run_input_dialog.
  [ 0 != "$state_last_run_button" ] && return

  local main_button=$1 # same as $state_yad_exit
  local ok_to_run=yes
#DEBUG { _dndmate_func_out; _dndmate_list_refs; } >&9
  if [ yes = $ok_to_run ]; then
    # Don't export DNDMATE_* variables except DNDMATE_LIST, DNDMATE_REFS, DNDMATE_EDITOR.
    # Don't export _dndmate and yad_lib_ functions. Test with command entry = 'env'.
    ## FIXME It shouldn't unexport DNDMATE envvars set in ancestors' envs, like
    ## from the user's .profile, but how to identify them?
    local unexported="-u YAD_OPTIONS -u YAD_GEOMETRY -u YAD_GEOMETRY_POPUP -u TEXTDOMAIN -u OUTPUT_CHARSET"
    unexported+=" $(_dndmate_list_existing --grepv='_LIST\b|_REFS\b|_EDITOR\b' export DNDMATE_ '-u ')"
    unexported+=" $(_dndmate_list_existing --grep='\b_dndmate|\byad_lib_' function '' '-u BASH_FUNC_' '%%')"
    # Run command for checked refs.
    select_refs '\0' |
    env $unexported xargs -0 $SHELL -c "$state_command_entry" "$SHELL" &
  fi
#DEBUG local ret=$?; { _dndmate_func_out; _dndmate_list_refs; } >&9; return $ret
}

sync_refs_lists() # {{{1
{
  # DNDMATE_REFS contains just the checked refs.
  select_refs > "$DNDMATE_REFS"
#DEBUG local ret=$?; { _dndmate_func_out; echo -n "from "; caller 1; _dndmate_list_refs; } >&9; return $ret
}

select_refs() # [$1-output-file-escaped-separator] [$2-list-file] [$3-TRUE|FALSE] {1
# Format output for $DNDMATE_REFS
{
  ! [ -s "$DNDMATE_LIST" ] && return
  # DNDMATE_LIST contains List widget columns checkbox,ref,urlencoded,@font@.
  local ofs=${1:-\\n} fin=${2:-$DNDMATE_LIST} selector=${3:-TRUE} fmt='%s'
  local checkbox ref rest
  while IFS='|' read -r checkbox ref rest; do
    if [ "$selector" = "$checkbox" ]; then
      printf "$fmt" "$ref"
      fmt="$ofs%s"
    fi
  done < "$DNDMATE_LIST"
}

_dndmate_urlencode() # $1-string $2-for-pango #{{{1
# https://stackoverflow.com/a/10660730 https://gist.github.com/cdown/1163649
# Non-null $2-for-pango requests less encoding of $1-string.
# Less encoding is sufficient for Pango tooltips to keep Pango from complaining
# about '&'.
{
  old_lc_collate="$LC_COLLATE"
  LC_COLLATE=C
  local string="$1"
  local pango=$2
  local strlen=${#string}
  local encoded pos c o

  if [ -z "$pango" ]; then
    for (( pos=0 ; pos<strlen ; pos++ )); do
      c=${string:$pos:1}
      case "$c" in
        [-_.~a-zA-Z0-9] ) o="$c" ;;
        * ) printf -v o '%%%02x' "'$c" ;;
       esac
       encoded+="$o"
    done
  else
    for (( pos=0 ; pos<strlen ; pos++ )); do
      c=${string:$pos:1}
      case "$c" in
        [\&\|] ) printf -v o '%%%02x' "'$c" ;;
        * ) o="$c" ;;
       esac
       encoded+="$o"
    done
  fi
  REPLY="$encoded"
  LC_COLLATE="$old_lc_collate"
  unset old_lc_collate
}; export -f _dndmate_urlencode

load_refs() # {{{1
# Output four columns to List widget: checkbox,ref,@font@,urlencoded
{
  local checkbox ref urlencoded font
  if [ -s "$DNDMATE_LIST" ]; then
    while IFS='|' read -r checkbox ref urlencoded font; do
      case $checkbox in TRUE|FALSE ) # defensive
        printf "%s\n%s\n%s\n%s\n" "$checkbox" "$ref" "$urlencoded" light ;;
      esac
    done < "$DNDMATE_LIST"
  elif [ -s "$DNDMATE_REFS" ]; then
    while read -r ref; do
      _dndmate_urlencode "$ref" for-pango # => $REPLY
      printf "%s\n%s\n%s\n%s\n" true "$ref" "$REPLY" light
    done < "$DNDMATE_REFS"
  fi
}

_dndmate_restart() # [--origin=N[.M]] [$*-dndmate-extra-options] {{{1
# Insert (and filter) script cmdline arguments before "$*" then exec.
# CAVEAT: This function must not be called in a sub-shell of the script's
# starting shell because of the design requirement that "the restarted script
# must keep the same PID of the restarter script". That is MAIN-AFTER's PID.
{
#DEBUGrun_button { printf "%5d %s: "  ${BASH_LINENO[0]} ${FUNCNAME[1]}; tail -n +${BASH_LINENO[0]} "${BASH_SOURCE[1]}" |head -1; }>&2
  local state_script_pid state_last_main_button
  _dndmate_get_state_with_lock
#DEBUG { _dndmate_func_in "_dndmate_restart pid($state_script_pid)"; } >&9
  case $1 in --origin=* )
    state_last_main_button="${1#*=}"; shift
    _dndmate_save_state_with_lock state_last_main_button # proxy origin
  esac
  local extra_options="$*"
  local a script_name_seen=no # no->now->before
  # Clear "$@".
  while [ $# -gt 0 ]; do shift; done
  # Read arguments/options from $DNDMATE_CMDLINE.
  while IFS= read -r -d '' a; do
    : "a($a)"
    # Filter out one-time-only options.
    case $a in -Z|--zap ) continue ;; esac
    case $script_name_seen in
      no ) [ "${a##*/}" = "${0##*/}" ] && script_name_seen=now ;;
      now ) script_name_seen=before ;;
    esac
    # Break at the first non-option (filepath or '')
    [ "$script_name_seen" = before -a "${a:1:1}" != - ] && break
    set -- "$@" "$a"
  done < "$DNDMATE_CMDLINE"
#DEBUGrun_button { printf "%5d %s: "  $LINENO $FUNCNAME; echo "exec_pid($$)"; }>&2
  exec "$@" $extra_options # exec it so it keeps the same pid
  # NOT-REACHED
}

add_command_line_refs() # $@-refs {{{1
# Add command-line REFs. Return 1 if script should exit.
{
  local state_script_pid
  # Append REFs to DNDMATE_LIST and DNDMATE_REFS
  _dndmate_itemize "$@"
#DEBUG { _dndmate_func_in; _dndmate_list_refs; } >&9

  # When command-line REFs are added, there is no need to show a GUI.
  # However, if a GUI is _already_ running, by default we restart it
  # so the restarted list view will show the added REFs.
  # But we don't restart the GUI if the user said so.
  [ -n "$opt_no_restart" ] && return 1

  # Kill the existing GUI because a new one is about to be started.
  _dndmate_get_state_with_lock
  if [ "$state_script_pid" ] && ps -ho pid $state_script_pid >/dev/null; then
    kill $state_script_pid
  fi
}

print_topics() # $1-comma-list-of-topics {{{1
{
  local IFS topic sep
  IFS=,
  for topic in $1; do
    : "topic $topic"
    [ -n "$sep" ] && echo
    sep=1
    case $topic in
      ref|refs ) cat "$DNDMATE_REFS"
        ;;
      check|checks ) cat "$DNDMATE_LIST"
        ;;
    esac
  done
}

show_main_dialog() # {{{1
# Start main paned dialog. Return yad exit value
{
  local s line_count msg
  local state_script_pid state_yad_exit state_yad_wintitle
  state_script_pid=$$; _dndmate_save_state_with_lock state_script_pid
  state_yad_wintitle=$YAD_WINTITLE; _dndmate_save_state_with_lock state_yad_wintitle
  # TODO possibly state_yad_wintitle won't be needed anymore after reviewing _dndmate_get_yad_pids
  # Save pid and title to a shared file for all script instances over time. TODO use it in _dndmate_get_yad_pids
  _dndmate_write_data_by_id_with_lock "$$"$'\t'"$YAD_WINTITLE" "${opt_id:-NULL}"

  if [ -n "$opt_append" -a -s "$DNDMATE_LIST" ]; then
    line_count=$(wc -l "$DNDMATE_LIST")
    line_count=${line_count%% *}
  else
    line_count=0
  fi
  set_APP_ICON_and_SPLITTER_SIZE
  s="--title='$YAD_WINTITLE' --buttons-layout=center"
  s+=" --window-icon=${APP_ICON:-gtk-dnd-multiple}"
  if [[ "$opt_style" =~ c ]]; then
    yad_lib_set_gtk2_STYLEFILE compact && s+=" --gtkrc=$STYLEFILE"
  else
    s+=" --borders=4"
  fi
  s+=" ${opt_width:+--width=}$opt_width ${opt_height:+--height=}$opt_height"
  export YAD_OPTIONS="$s"

  msg=$(printf "<i>$(gettext \
    "Drop target adds to '%s' @%d")</i>" "$DNDMATE_REFS" $((1+$line_count)))

  {
    # If --append then insert stored refs at the top of the list widget.
    [ -n "$opt_append" ] && load_refs
    # Pluggable drag-and-drop widget outputs dropped item refs.
    yad --dnd --plug=$$ --tabnum=1 \
      --command "bash -O extdebug -c _dndmate_itemize '_dndmate_itemize'" \
      --image="$APP_ICON"
  } |
  {
  # Pluggable list widget shows and outputs checkboxed refs.
  [ -n "$opt_no_edit" ] && editable= || editable=--editable
  local expander
  # U+00A0 Dec:160 NO-BREAK SPACE (NS) &nbsp; &NonBreakingSpace; /\%ua0 $'\xc2\xa0'
  [[ $opt_style =~ x ]] && expander="--expander="$'\ua0'

  local no_headers="--no-headers" hide_column="--hide-column=3"
  [ "$DNDMATE_UNHIDE_COLUMNS" ] && unset no_headers hide_column # undocumented
  yad --list --plug=$$ --tabnum=2 \
    $expander \
    $editable --regex-search $no_headers --no-markup \
    --column=:CHK \
    --column="$(gettext Reference)" --search-column=2 \
    --column=urlencoded --tooltip-column=3 $hide_column \
    --column=@font@ \
    --print-all --ellipsize=START |

  # Awk buffers yad --list output because we can clobber DNDMATE_LIST only
  # after yad --dnd has closed.
  awk -v OUTFILE="$DNDMATE_LIST" '
    {a[++n] = $0}
    END {for(i = 1; i <= n; i++) print a[i] >OUTFILE}
  '
#DEBUG-insert-above { print "AWK BUFFER seen("$0")" >"/dev/stderr" }
#DEBUG { _dndmate_func_in "yad --list exited; syncing refs lists"; } >&9
  sync_refs_lists # DNDMATE_LIST updates => DNDMATE_REFS
  } &
  # Assign button labels, icons and tooltips.
  set_B_L_I_T "$msg"
  set_SPLITTER_WORKAROUND
  # Show paned dialog, which embeds (maximum two) pipelined dialogs.
  local S=$'\b' # yad value item separator
  local orient=hor splitter=$SPLITTER_SIZE # in px
  [[ $opt_style =~ v ]] && orient=vert splitter=0 # yad appears to auto-fit in vert case
  yad --paned     --key=$$  --orient=$orient --splitter=$splitter \
      $DNDMATE_YAD_OPTIONS \
      ${YAD_GEOMETRY:-$DNDMATE_YAD_INITIAL_POSITION} \
      --tooltip --item-separator=${S} \
      "${B[zap_]}${L[zap_]}${S}${I[zap_]}${S}${T[zap_]}:bash -c '_dndmate_handle_main_button  1 USR2'" \
      "${B[quit]}${L[quit]}${S}${I[quit]}${S}${T[quit]}:101" \
      "${B[run1]}${L[run1]}${S}${I[run1]}${S}${T[run1]}:bash -c '_dndmate_handle_main_button 12 USR1'" \
      "${B[edit]}${L[edit]}${S}${I[edit]}${S}${T[edit]}:bash -c '_dndmate_handle_main_button  4 USR2'" \
      "${B[help]}${L[help]}${S}${I[help]}${S}${T[help]}:'$0' --help=gui" \
      ${B[none]} $SPLITTER_WORKAROUND
  state_yad_exit=$?; _dndmate_save_state_with_lock state_yad_exit
  return $state_yad_exit
}

_dndmate_get_yad_pids() # $1-PPID $2-yad-wintitle $3-array-varname {{{1
# Get the PIDs of all running yad processes that share my --id.
# Assign by reference to elements of array-varname the PIDs of PPID's yad children, where array
# elements [0]..[2] correspond to PPID's --paned, --dnd, and --list respectively, and
# elements[3]... to other sub-dialogs.  Element[i] == 0 => invalid/not found.
{
#DEBUG_state { printf "%5d %s: "  ${BASH_LINENO[0]} ${FUNCNAME[1]}; tail -n +${BASH_LINENO[0]} "${BASH_SOURCE[1]}" |head -1; }>&2
  local -n pA=$3
  local ppid=${1:--1} yad_wintitle="$2" rec n IFS=$' \t\n'
  set -- $(pidof yad)
  [ 0 = $# ] && return
  pA=( 0 0 0 ); n=2 # next element
  local IFS=$'\n'
  set $(ps -ho pid,cmd $*)
  shopt -s extglob # for trim left
  for rec; do
    rec="${rec/#+([[:blank:]])/}" # trim left
    if [[ "$rec" == *"--title=$yad_wintitle"* ]]; then
      pA[((++n))]=${rec%% *} # found a sub-dialog such as Run
    elif ! [[ "$rec" =~ --(plug|key)"=$ppid" ]]; then
      continue # not in Main dialog
    fi
    if [[ "$rec" == *"--paned "* ]]; then pA[0]=${rec%% *}
    elif [[ "$rec" == *"--dnd "* ]]; then pA[1]=${rec%% *}
    elif [[ "$rec" == *"--list "* ]]; then pA[2]=${rec%% *}
    fi
  done
  IFS=" "
  [ "0 0 0" = "${pA[*]}" ] && pA=( ) || :
}; export -f _dndmate_get_yad_pids

_dndmate__yad() # $@-yad-options {{{1
# Sub-dialogs call _dndmate__yad instead of yad.
{
  # Now _dndmate_get_yad_pids can identify this dialog by --title.
  # Note that --title is imported via $YAD_OPTIONS.
  local IFS=' '
  yad ${YAD_GEOMETRY_POPUP:---height=1} "$@"
}; export -f _dndmate__yad

_dndmate_handle_main_button() # $1-main-button $2-signal {{{1
# CAVEAT: do not call _dndmate_restart from this function.
# _dndmate_restart should be called only by MAIN-AFTER's process.
# $2-signal ::= 'USR1'|'USR2' - Cf. man yad.
# TLDR; USR1: flush list contents to stdout then close Main dialog. USR2 no flush then close.
{
  [[ $1 =~ ^[[:digit:]]+$ && $2 == USR[12] ]] || return 1
  local main_button=$1 signal="$2" scaling
  # Save main_button for MAIN-AFTER.
  local state_last_main_button=$main_button; _dndmate_save_state_with_lock state_last_main_button
  case $main_button in
    1 ) : "Main button Zap"
      : empty REFS > "$DNDMATE_REFS"
      : empty LIST > "$DNDMATE_LIST"
      ;;
    2|12 ) : "Main buttons Run/Run1"
      scaling="100:50:-1:-1"
      # Further steps take place in MAIN-AFTER to avoid calling _dndmate_restart here.
      _dndmate_show_run_input_dialog $main_button
      ;;
    4 ) : "Main button Edit"
      # Set popup geometry.
      yad_lib_set_YAD_GEOMETRY
      $DNDMATE_EDITOR "$DNDMATE_LIST" &
      _dndmate__yad --text "$(gettext \
        "To resume $SN when you are done editing,\nsave the file, close the editor, and click OK.")" \
        --center --button=gtk-ok --window-icon=gtk-edit
      ;;
    * ) : unhandled
      die_printf $main_button "$(gettext "unexpected button event %d, line %d")\n" $main_button $LINENO
      ;;
  esac
  # Save geometry again for restarting the dialog.
  yad_lib_set_YAD_GEOMETRY "" "" "$scaling"
  local state_YAD_GEOMETRY=$YAD_GEOMETRY; _dndmate_save_state_with_lock state_YAD_GEOMETRY
  local state_YAD_GEOMETRY_POPUP=$YAD_GEOMETRY_POPUP; _dndmate_save_state_with_lock state_YAD_GEOMETRY_POPUP
  # Restart main dialog in MAIN-AFTER.
  kill -$signal $YAD_PID
}; export -f _dndmate_handle_main_button

die_printf() # [--usage] $1-exit-code|10 $2-format [$3%-arguments] {{{1
# $2% may be gettexted, i.e. "$(gettext "file %s is...%s\n")" "$file" "$(gettext "open")"
{
  [ "$1" = --usage ] && { usage; shift; }
  local status fmt cmd
  status="$1" fmt="$2"; shift 2
  if [ "$fmt" ]; then
    if [ -t 0 ]; then
      printf "%s: $fmt" "$(basename "$0")" "$@" >&2
    else
      yad --title="$(basename "$0")" --window-icon=gtk-stop \
        --timeout=8 --buttons-layout=center --borders=4 \
        --center --on-top --text "$(printf "$fmt" "$@")"
    fi
  fi
  exit $status
}

# q_*: handlers for queued options. #{{{1}}}
q_close() # {{{1
{
#DEBUG_state { printf "%5d %s: "  ${BASH_LINENO[0]} ${FUNCNAME[1]}; tail -n +${BASH_LINENO[0]} "${BASH_SOURCE[1]}" |head -1; }>&2
  local IFS=$'\n' i pid title
  local -a YadPid Instance
  # Get all other instances (existing and possibly exited) that share my id.
  Instance=( $(_dndmate_read_data_by_id_with_lock "${opt_id:-NULL}") )
  IFS=$'\t' i=0
  while ((++i < ${#Instance[@]})); do
    set -- ${Instance[$i]}
    pid=$1 title="$2" # of another instance
    # Get its yad process pids.
    unset YadPid
    _dndmate_get_yad_pids $pid "$title" YadPid
    if ((${#YadPid[@]})); then
      local pid_paned=${YadPid[0]} pid_dnd=${YadPid[1]} pid_list=${YadPid[2]} pid_sub_dialogs="${YadPid[@]:3}"
      pid="${YadPid[@]#0}" # delete pids==0
      ! [[ $pid =~ [1-9] ]] && break # no positive pids, done
      if (( $pid_paned > 1 )); then
        kill -USR1 $pid_paned # killing --paned kills --dnd and --list
      else
        # Might leave ghosts around and busy shmem.
        [[  $pid_dnd > 1 ]] && kill $pid_dnd
        [[ $pid_list > 1 ]] && kill $pid_list
      fi
      if [[ $pid_sub_dialogs =~ [1-9] ]]; then
        sleep .1
        kill $pid_sub_dialogs
      fi
      _dndmate_write_data_by_id_with_lock "" "${opt_id:-NULL}" "w" # clear record
    fi
  done
}

q_exit() # {{{1
{
  exit
}

q_zap() # {{{1
{
  [ -z "$opt_zap" ] && return
  : REFS > "$DNDMATE_REFS"
  : LIST > "$DNDMATE_LIST"
}

#DEBUG {{{1
_dndmate_func_in()  { _dndmate_recho ">>> $(date +%s)" "${1:+ }$1" " "; caller 0; }
_dndmate_func_out() { _dndmate_recho "<<< $(date +%s)" "${1:+ }$1" " "; caller 0; }
_dndmate_list_refs() { echo "$DNDMATE_LIST"; cat -n "$_"; echo "$DNDMATE_REFS"; cat -n "$_"; true; }
_dndmate_recho() # $(1)...$(n-1) ''|' '|'\n'
# Print the first $#-1 arguments in ANSI reverse video
# then print the last argument.
{
  printf "\033[7m"
  printf "%s%s" "${@:1:$(($# - 1))}" "${IFS:1:1}"
  printf "\033[0m${@: -1:1}"
}
export -f _dndmate_recho _dndmate_func_in _dndmate_func_out _dndmate_list_refs
alias _mtail='defaultterm -name TeY -e multitail -P a -M 10000 --no-repeat -cT ANSI -ts -iw "/tmp/.$USER-dndmate*" 10 -ts -iw "/tmp/$USER-dndmate-refs*" 10 -ts -iw "/tmp/$USER-dndmate-hist*" 10'

exec 9>/dev/null # Default: make DEBUG output invisible.
#exec 9>&2 # Optional: send DEBUG output to stderr.
#exec 1>&9 2>&9 # Optional: send stdout/stderr to DEBUG.
#! [[ "$*" == *--debug* ]] && set -- --debug "$@"; # Dev: force DEBUG mode.

# INIT 1 {{{1
export TEXTDOMAIN=dndmate OUTPUT_CHARSET=UTF-8
# SN affects window title, icon name, ROX app and debug log.
SN=dndmate # vs. ${0##*/}
DEBUG_LOG_FILE="${TMPDIR:-/tmp}/debug-$USER-$SN-$$.log"
alias awk=gawk
DNDMATE_REFS=${DNDMATE_REFS:-"${TMPDIR:-/tmp}/$USER-$SN-refs%s.txt"}
DNDMATE_HISTORY=${DNDMATE_HISTORY:-"${TMPDIR:-/tmp}/$USER-$SN-history%s.sh"}
! [ -x "$DNDMATE_EDITOR" ] &&
  ! type -p "$DNDMATE_EDITOR" >/dev/null &&
  DNDMATE_EDITOR=$(which defaulttexteditor geany leafpad 2>/dev/null | head -1)

# PARSE COMMAND LINE {{{1
# Option format: -x[=parm] | --opt-x[=parm]
# Short options can't be combined together. Space can't substitute '=' before
# option value.  $optIndex points to the current option ($opt) while parsing,
# and to the first non-option argument, if any, after parsing. $# is the number
# of arguments.
unset opt_append opt_bgcolor opt_append_exit opt_fgcolor opt_font_family opt_glyph opt_height opt_id opt_mult opt_no_edit opt_no_restart opt_optf opt_print opt_style opt_stylef opt_uniq opt_width opt_zap
optIndex=1 optQueue=
while [[ "${!optIndex}" == -* ]]; do
  opt=${!optIndex}; ((++optIndex))
  if [[ $opt =~ --([bf]gcolor|font-family|glyph(-scale)?|height|mult|optf|print|stylef?|width)=?$ ]]; then
    usage "$opt"; die_printf 1 "%s: $(gettext 'option needs a value')\n" "$opt" >&2
  fi
  case $opt in
    -a|--append) opt_append=true ;;
    --append-exit) opt_append_exit=true ;;
    --bgcolor=*) opt_bgcolor="${opt#*=}" ;;
    --close) optQueue+=" close" ;;
    --font-family=*) opt_font_family="${opt#*=}" ;;
    --fgcolor=*) opt_fgcolor="${opt#*=}" ;;
    --style=*) opt_style="${opt#*=}" ;;
    --stylef=*:*) opt_stylef=${opt#*=} ;;
    --debug|--debug=*)
      [[ $opt == --debug=* ]] && DEBUG_LOG_FILE=${opt:9}
      exec 9>> "$DEBUG_LOG_FILE"
      BASH_XTRACEFD=9
      printf "$(gettext "Writing -x trace to fd 9 '%s'\n")" "$DEBUG_LOG_FILE" >&2
      x=`date`
      set -x
      : "#### START $$ args $@ #### $x ####"
      ;;
    --exit) optQueue+=" exit" ;;
    --glyph=?) opt_glyph="${opt#*=}" ;;
    --glyph-scale=*) [[ $opt =~ =(100|[1-9][0-9]|[1-9])%?$ ]] ||
        die_printf 1 "$(gettext "%s : value must be integer in range 1..100")\n" "$opt"
        opt_glyph_scale=${BASH_REMATCH[1]} ;;
    -h|--help|-h=*|--help=*) usage "$opt"; exit ;;
    --id) opt_id=$$ ;;
    --id=?*) opt_id="${opt#*=}" ;;
    --height=[1-9]*) opt_height="${opt#*=}" ;;
    --mult=[1-9]*) opt_mult="${opt#*=}" ;;
    --no-edit) opt_no_edit=true ;;
    --no-restart) opt_no_restart=true ;;
    --optf=?*) opt_optf="${opt#*=}" # read options from file
      ! [ -e "$opt_optf" ] && opt_optf="${0%/*}/$opt_optf"
      ! [ -e "$opt_optf" ] && die_printf 1 "$(gettext "\"%s\" : file not found for %s")\n" "${opt#*=}" --optf
      readarray -t < "$opt_optf"
      set -- "${@:1:$((optIndex-2))}" "${MAPFILE[@]}" "${@:$((optIndex))}"
      ((--optIndex))
      unset MAPFILE
      ;;
    --print=?*) opt_print="${opt#*=}" ;;
    --uniq) opt_uniq=true ;;
    --version) echo $Version; exit ;;
    --width=[1-9]*) opt_width="${opt#*=}" ;;
    -Z|--zap) optQueue+=" zap"; opt_zap=true ;;
    --) break ;;
    -*) usage; die_printf 1 "$(gettext "%s : unknown option")\n" "$opt"
      ;;
  esac
done # $@ gets shifted further down.
[ -n "$opt_append" ] && unset opt_zap
[ -z "$opt_zap" ] && opt_append=true
[ -n "$opt_stylef" ] && set_options_from_stylef "$opt_stylef"
opt_style=${opt_style:-}
opt_mult=${opt_mult:-5} # integer - dnd image side = 16 * opt_mult px
opt_glyph=${opt_glyph:-$'\u25ce'} # U+25CE Dec:9678 BULLSEYE (0o)
opt_glyph_scale=${opt_glyph_scale:-90} # percent
opt_font_family=${opt_font_family:-} # for system default font leave empty
opt_fgcolor=${opt_fgcolor:-#4c4c4c}
opt_bgcolor=${opt_bgcolor:-none} # for transparent color use "none"

# INIT 2 {{{1
export DNDMATE_EDITOR # for _dndmate_show_run_input_dialog
# Permanent store of clear-text refs (dropped items).
export DNDMATE_REFS # for spawned COMMANDs and _dndmate_itemize
DNDMATE_REFS=$(printf "$DNDMATE_REFS" "$opt_id")
# Permanent store of check-boxed refs (yad list widget).
x=${DNDMATE_REFS##*/}; x=${x%.*}
export DNDMATE_LIST="${DNDMATE_REFS%/*}/.$x.${DNDMATE_REFS##*.}" # for spawned COMMANDs
# Lock file for _dndmate_itemize
export DNDMATE_LOCK="${TMPDIR:-/tmp}/.$USER-$SN-$$-lock"
rm -f "$DNDMATE_LOCK"
# Script state store: user input, yad exit status, button ids, and more.
export DNDMATE_STATE="$DNDMATE_LIST.state"
# Shared db - all scripts can access with lock
export DNDMATE_DATA_BY_ID="${TMP:-/tmp}/.$USER-$SN-data-by-id"
# Command history is saved here.
DNDMATE_HISTORY=$(printf "$DNDMATE_HISTORY" "$opt_id")
# Null-separated command-line as in /proc/$$/cmdline is saved here.
export DNDMATE_CMDLINE="$DNDMATE_LIST.cmdline"
printf "%s\0" "$BASH" "$0" "$@" > "$DNDMATE_CMDLINE"
shift $((optIndex - 1))
# Used to identify the Main window and its running sub-dialogs.
YAD_WINTITLE="${opt_id:-[$$]} - $SN"

# MAIN {{{1
# Process queued options.
for x in $optQueue; do eval q_$x || exit 1; done
# If not appending and no existing refs/list data
if [ -z "$opt_append" -a ! -s "$DNDMATE_REFS" -a ! -s "$DNDMATE_LIST" ]; then
  : REFS > "$DNDMATE_REFS"
  : LIST > "$DNDMATE_LIST"
fi
#DEBUG { _dndmate_func_in; _dndmate_list_refs; } >&9
if [ 0 != $# ]; then
  add_command_line_refs "$@" || exit
fi
if [ -n "$opt_print" ]; then
  print_topics "$opt_print"
  exit
fi
[ -n "$opt_append_exit" ] && exit
# Import yad_lib_set_YAD_GEOMETRY yad_lib_set_gtk2_STYLEFILE
. yad-lib.sh >/dev/null &&
  export -f yad_lib_set_YAD_GEOMETRY &&
  show_main_dialog
exit_code=$?

# MAIN-AFTER the main dialog has closed... {{{1
#DEBUG { _dndmate_func_out "exit_code($exit_code)"; _dndmate_list_refs; } >&9
_dndmate_get_state_with_lock; main_button_error=$?
#DEBUGrun_button { printf "%5d: "  $LINENO; echo "exit_code($exit_code) main_button_error($main_button_error)"; }>&2
if [ 0 = $main_button_error ]; then
  export YAD_GEOMETRY=$state_YAD_GEOMETRY YAD_GEOMETRY_POPUP=$state_YAD_GEOMETRY_POPUP
  last_main_button=$state_last_main_button
#DEBUGrun_button { printf "%5d: "  $LINENO; echo "last_main_button($last_main_button)"; }>&2
fi
case $exit_code in
  101|252|143 ) : "events: Main button Quit, window close, ESC; kill -TERM"
    state_last_main_button=$exit_code; _dndmate_save_state_with_lock state_last_main_button
    exit $exit_code
    ;;
  0 ) : "events: Main buttons Run/Run1, kill -USR1"
    case $last_main_button in
      2|12 ) : Run/Run1
          confirm_then_run_command $last_main_button
          _dndmate_restart --origin=$last_main_button
        # NOT-REACHED
        ;;
      2.*|12.* ) : Run dialog button
        exit ${last_main_button%%.*}
        ;;
      101|143 ) : q_close action ;;
      252 ) : exit from debugger ;;
      * ) main_button_error=1 ;;
    esac
    ;;
  1 ) : "events: Main buttons Zap/Edit, kill -USR2"
    case $last_main_button in
      1|4 ) : Zap/Edit
        _dndmate_restart
        # NOT-REACHED
        ;;
      * ) main_button_error=1 ;;
    esac
    ;;
  * )
    die_printf 99 "$(gettext "unexpected exit event %d, line %d")\n" $exit_code $LINENO
    ;;
esac
[ 1 = $main_button_error ] && die_printf 97 "$(gettext "unexpected button event %d, line %d")\n" $last_main_button $LINENO
